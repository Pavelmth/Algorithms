package ru.pavel.algorithms;

/**
 * 1. Создать и запустить программу для построения двоичного дерева. В цикле построить двадцать деревьев с глубиной в 6 уровней.
 * Данные, которыми необходимо заполнить узлы деревьев, представляются в виде чисел типа int.
 * Число, которое попадает в узел, должно генерироваться случайным образом в диапазоне от -100 до 100.
 * 2. Проанализировать, какой процент созданных деревьев являются несбалансированными.
 * Необходимые определения:
 *
 * 1.Высота данного узла - максимальная длина нисходящего пути от этого узла к самому нижнему листу.
 * 2.Высота дерева - это высота корня.Высота дерева состоящего из одного корня равно 0.Высоту пустого дерева будем тоже считать равной 0.
 * 3.Сбалансированное по высоте дерево - это дерево для каждой вершины которого высота её двух поддеревьев различается не более чем на 1.
 * Пустое дерево будем считать сбалансированным.
 *
 * 4.
 * Алгоритм действий:
 *
 * 1.Добавить поле height, которое хранит высоту данного узла. При вставке и удалении узла обновлять это поле так же, как и size. ###
 * 2.Изменить конструктор Node. При создании нового узла в методе put, указывать высоту 0.
 * 3.Добавить аналогично полю size, открытый и закрытый методы height().
 * 4.Сбалансированность дерева определяем с помощью метода isBalanced(). Этод метод рекурсивно проверяет сбалансированность всех узлов.
 */
public class App 
{
    public static void main( String[] args )
    {
        MyTreeMap<Character, Integer> tree = new MyTreeMap<>();
        tree.put('s',0);
        tree.put('e',0);
        tree.put('a',0);
        tree.put('r',0);
        tree.put('c',0);
        tree.put('h',0);
        tree.put('x',0);
        tree.put('m',0);
        tree.remove('e');
    }
}
